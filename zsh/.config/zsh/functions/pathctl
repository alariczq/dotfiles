#!/usr/bin/env zsh

# PATH management utility
# Environment file path configuration
ENVFILEPATH=${ENVFILEPATH:-${XDG_CONFIG_HOME:-$HOME/.config}/zsh/.env}

# Utility functions for path manipulation
_pathctl_unique() {
  awk '!seen[$0]++'
}

_pathctl_join() {
  local sep="${1:-:}"
  awk -v sep="$sep" '{ output = output ? output sep $0 : $0 } END { print output }'
}

_pathctl_read_env() {
  local env_file="${1:-$ENVFILEPATH}"
  [[ ! -f "$env_file" ]] && return 1
  
  # Parse environment file: remove comments, trim whitespace, skip empty lines
  sed -e 's/#.*//; s/^[[:blank:]]*//; s/[[:blank:]]*$//' \
      -e '/^$/d' \
      -e 's/.*/[ -d "&" ] \&\& echo &/' "$env_file" | sh
}

load_paths() {
  local env_file="${1:-$ENVFILEPATH}"
  echo "$(_pathctl_read_env "$env_file" | _pathctl_join):$PATH" | 
    tr ':' '\n' | _pathctl_unique | _pathctl_join
}

_pathctl_err() {
  echo "pathctl: $*" >&2
}

_pathctl_precheck() {
  local file_path="${1:-$ENVFILEPATH}"
  
  # Create file if it doesn't exist
  if [[ ! -e "$file_path" ]]; then
    touch "$file_path" || {
      _pathctl_err "Failed to create \"$file_path\""
      return 1
    }
    return 0
  fi

  # Check if it's a regular file
  if [[ ! -f "$file_path" ]]; then
    _pathctl_err "\"$file_path\" is not a file"
    return 1
  fi

  # Check if it's writable
  if [[ ! -w "$file_path" ]]; then
    _pathctl_err "\"$file_path\" is not writable"
    return 1
  fi
}

_pathctl_normalize_path() {
  local path="$1"
  
  # Check if directory exists
  if [[ ! -d "$path" ]]; then
    _pathctl_err "\"$path\": Not a directory"
    return 1
  fi

  # Get absolute path
  realpath "$path" 2>/dev/null || {
    _pathctl_err "\"$path\": Invalid path"
    return 1
  }
}

_pathctl_build_targets() {
  local targets=""
  local target normalized
  
  for target in "${@:-$(pwd)}"; do
    normalized=$(_pathctl_normalize_path "$target") || return 1
    
    if [[ -n "$targets" ]]; then
      targets+=":$normalized"
    else
      targets="$normalized"
    fi
  done
  
  echo "$targets"
}

_pathctl_update_env_cache() {
  local env_file="${1:-$ENVFILEPATH}"
  local cache_var="_PATHCTL_ENV_$(echo "$env_file" | tr './' '_')"
  eval "$cache_var='$(_pathctl_read_env "$env_file" | _pathctl_unique | _pathctl_join)'"
}

_pathctl() {
  local cmd="${1:-help}"
  [[ $# -gt 0 ]] && shift

  case "$cmd" in
    put)
      _pathctl_precheck "$ENVFILEPATH" || return 1

      local targets
      targets=$(_pathctl_build_targets "$@") || return 1

      # Get existing paths from environment file
      local existing_paths
      existing_paths=$(_pathctl_read_env | _pathctl_join)

      # Create temporary file for atomic update
      local temp_file
      temp_file=$(mktemp) || {
        _pathctl_err "Failed to create temporary file"
        return 1
      }

      # Add new paths that don't already exist
      awk -v home="$HOME" -v existing="$existing_paths" -v new_targets="$targets" '
      BEGIN {
        # Build lookup table for existing paths
        split(existing, paths, ":")
        for (i in paths) {
          if (paths[i] != "") seen[paths[i]] = 1
        }

        # Add new targets in reverse order (prepend)
        split(new_targets, targets, ":")
        for (i = length(targets); i >= 1; i--) {
          if (targets[i] != "" && !seen[targets[i]]) {
            gsub("^" home, "$HOME", targets[i])
            print targets[i]
          }
        }
      }
      { print }
      ' "$ENVFILEPATH" > "$temp_file" && mv "$temp_file" "$ENVFILEPATH"

      # Update PATH and cache
      export PATH=$(load_paths)
      _pathctl_update_env_cache
      ;;

    ls)
      if [[ ! -e "$ENVFILEPATH" ]]; then
        _pathctl_err "\"$ENVFILEPATH\": File not found"
        return 1
      fi

      if [[ "$1" == "-p" ]]; then
        _pathctl_read_env "$ENVFILEPATH"
      else
        cat "$ENVFILEPATH"
      fi
      ;;

    ls-paths)
      echo "$PATH" | tr ':' '\n'
      ;;

    del)
      _pathctl_precheck "$ENVFILEPATH" || return 1

      local targets
      targets=$(_pathctl_build_targets "$@") || return 1

      # Remove from environment file
      local temp_file
      temp_file=$(mktemp) || {
        _pathctl_err "Failed to create temporary file"
        return 1
      }

      # Get environment paths for deletion
      local env_paths
      env_paths=$(_pathctl_read_env | _pathctl_join)

      # Create sed expression to delete matching lines
      local sed_expr
      sed_expr=$(awk -v env_paths="$env_paths" -v targets="$targets" '
      BEGIN {
        split(targets, target_arr, ":")
        split(env_paths, env_arr, ":")
        
        for (i in target_arr) {
          for (j in env_arr) {
            if (env_arr[j] == target_arr[i]) {
              expr = expr j "d;"
            }
          }
        }
        print expr
      }')
      
      if [[ -n "$sed_expr" ]]; then
        sed "$sed_expr" "$ENVFILEPATH" > "$temp_file" && mv "$temp_file" "$ENVFILEPATH"
      fi

      # Remove from current PATH
      local new_path
      new_path=$(awk -v current_path="$PATH" -v targets="$targets" '
      BEGIN {
        split(targets, target_arr, ":")
        for (i in target_arr) {
          if (target_arr[i] != "") to_remove[target_arr[i]] = 1
        }

        split(current_path, path_arr, ":")
        for (i in path_arr) {
          if (path_arr[i] != "" && !to_remove[path_arr[i]]) {
            result = result ? result ":" path_arr[i] : path_arr[i]
          }
        }
        print result
      }')
      
      [[ -n "$new_path" ]] && export PATH="$new_path"
      _pathctl_update_env_cache
      ;;

    load)
      local file_path="${1:-$ENVFILEPATH}"
      
      if [[ ! -f "$file_path" ]]; then
        _pathctl_err "\"$file_path\": No such file or not a file"
        return 0
      fi

      # Remove previously loaded paths from this file
      local cache_var="_PATHCTL_ENV_$(echo "$file_path" | tr './' '_')"
      local previously_loaded
      eval "previously_loaded=\$$cache_var"

      if [[ -n "$previously_loaded" ]]; then
        export PATH=$(echo "$PATH" | tr ':' '\n' | 
          awk -v prev="$previously_loaded" '
          BEGIN { 
            split(prev, paths, ":")
            for (i in paths) {
              if (paths[i] != "") to_remove[paths[i]] = 1
            }
          }
          !to_remove[$0]
          ' | _pathctl_join)
      fi

      # Load new paths
      export PATH=$(load_paths "$file_path")
      _pathctl_update_env_cache "$file_path"
      ;;

    edit)
      ${EDITOR:-vim} "$ENVFILEPATH"
      _pathctl load "$ENVFILEPATH"
      ;;

    tidy)
      _pathctl_precheck "$ENVFILEPATH" || return 1

      _pathctl_read_env | 
        sed "s#$HOME#\$HOME#g" | 
        _pathctl_unique > "$ENVFILEPATH"
      ;;

    help|*)
      cat >&2 << 'EOF'
pathctl - PATH environment variable management utility

USAGE:
  pathctl [COMMAND] [OPTIONS]

COMMANDS:
  put [PATH]...       Add directories to PATH (default: current directory)
  del [PATH]...       Remove directories from PATH (default: current directory)
  ls [-p]             List PATH entries from environment file
                      -p: show resolved paths
  ls-paths            List current $PATH entries
  load [FILE]         Load PATH entries from file
  edit                Edit environment file with $EDITOR
  tidy                Clean and deduplicate environment file
  help                Show this help message

ENVIRONMENT:
  ENVFILEPATH         Path to environment file
                      (default: $XDG_CONFIG_HOME/zsh/.env)
  EDITOR              Editor for 'edit' command (default: vim)

EXAMPLES:
  pathctl put /usr/local/bin        # Add directory to PATH
  pathctl del /usr/local/bin        # Remove directory from PATH
  pathctl put . ../bin              # Add multiple directories
  pathctl ls -p                     # List resolved paths
  pathctl tidy                      # Clean environment file
EOF
      ;;
  esac
}

_pathctl "$@"
